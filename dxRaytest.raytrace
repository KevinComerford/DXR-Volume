#include "UnityShaderVariables.cginc"
#include "Noise.cginc"
#pragma exclude_renderers d3d11
#pragma only_renderers d3d12

#pragma max_recursion_depth 1

#define M_PI 3.1415926535897932384626433832795

#define LightBatch 128



// Input
RaytracingAccelerationStructure g_SceneAccelStruct;


//Point
uint	PointLightCount;
float3	PointLightsWS[LightBatch];
float4	PointLightsColor[LightBatch];

//Cone
uint	ConeLightCount;
float3	ConeLightsWS	[LightBatch];
float3	ConeLightsDir	[LightBatch];
float4	ConeLightsColor	[LightBatch];
float2	ConeLightsPram	[LightBatch]; //Outter , inner

//Direction
uint	DirLightCount;
float3	DirLightsDir[LightBatch];
float4	DirLightsColor[LightBatch];

//Area 
uint	AreaLightCount;
uint	AreaLightSamples;
float4x4	AreaLightsMatrix[LightBatch];
float4x4	AreaLightsMatrixInv[LightBatch];
float3	AreaLightsWS[LightBatch];
float4	AreaLightsColor[LightBatch];
float3	AreaLightsSize[LightBatch];


float3	WPosition;
float3	Size = float3(1,1,1);

// Output
RWTexture3D<float4> g_Output;

struct RayPayload
{
    float4 color;
};

[shader("miss")]
void MainMissShader(inout RayPayload payload : SV_RayPayload)
{
    payload.color = float4(1, 1, 1, 1);
}

float InverseSquare(float distance){
	return	1 / (4 * M_PI * distance * distance);
}

//float _Seed;

float rand(float2 Pixel)
{
    float _Seed = Pixel.x + Pixel.y ;

	float result = frac(sin(_Seed / 100.0f * dot(Pixel, float2(12.9898f, 78.233f) ) ) * 43758.5453f);
//	_Seed = _Seed + 1.0f;
	return result;
}

float rand(float3 Pixel)
{
    float _Seed = Pixel.x + Pixel.y + Pixel.z ;

	float result = frac(sin(_Seed / 100.0f * dot(Pixel, float3(12.9898f, 49.1165f, 29.1165f))) * 43758.5453f);
//	_Seed += 1.0f;
	return result;
}

//Casts ray from voxel to point light. If there's a hit, the voxel is in shadow.
///Point light
///
float4 PointLightCast(float3 VoxelWS, uint Num){

	float LightRadius = distance(VoxelWS, PointLightsWS[Num] ); 
    float3 rayDirection =  -normalize(VoxelWS - PointLightsWS[Num])  ;

    RayDesc ray;
    ray.Origin    = VoxelWS;
    ray.Direction = rayDirection;
    ray.TMin      = 0.0f;
    ray.TMax      = LightRadius;

    RayPayload payload;
    payload.color = float4(0, 0, 0, 0);

    uint missShaderIndex = 0;
    TraceRay(g_SceneAccelStruct, 0, 0xFF, 0, 1, missShaderIndex, ray, payload); //Add an anyhit shader to support transparencies 

	return payload.color * InverseSquare(LightRadius) * PointLightsColor[Num];
}

///
/// Cone light
///

float4 ConeLightCast(float3 VoxelWS, uint Num){


    float3 rayDirection =  -normalize(VoxelWS - ConeLightsWS[Num])  ;

	//Currently taking a point light and adding attenuation
	float attenuation = (dot(ConeLightsDir[Num], -rayDirection));

    if (attenuation <= 0) return float4(0, 0, 0, 0); //early out

    float LightRadius = (distance(VoxelWS, ConeLightsWS[Num] )); 

	/////
	float flOuterConeCos = ConeLightsPram[Num].x;
	float flTemp = dot(ConeLightsDir[Num], -rayDirection) - flOuterConeCos;
	float vSpotAtten = saturate(flTemp * ConeLightsPram[Num].y);
	///

    RayDesc ray;
    ray.Origin    = VoxelWS;
    ray.Direction = rayDirection;
    ray.TMin      = 0.0f;
    ray.TMax      = LightRadius;

    RayPayload payload;
    payload.color = float4(0, 0, 0, 0);

    uint missShaderIndex = 0;
    TraceRay(g_SceneAccelStruct, 0, 0xFF, 0, 1, missShaderIndex, ray, payload); //Add an anyhit shader to support transparencies 

	return  InverseSquare(LightRadius) * vSpotAtten * payload.color * ConeLightsColor[Num];
}

//
//Directional Light
//

float4 DirLightCast(float3 VoxelWS, uint Num){

    float3 rayDirection = -DirLightsDir[Num];

    RayDesc ray;
    ray.Origin    = VoxelWS;
    ray.Direction = rayDirection;
    ray.TMin      = 0.0f;
    ray.TMax      =  1000.0f;

    RayPayload payload;
    payload.color = float4(0, 0, 0, 0);

    uint missShaderIndex = 0;
    TraceRay(g_SceneAccelStruct, 0, 0xFF, 0, 1, missShaderIndex, ray, payload); //Add an anyhit shader to support transparencies 

	return  payload.color * DirLightsColor[Num];
}

//
//Area Light
//

float4 AreaLightCast(float3 VoxelWS, uint Num){
  //  
    float3 lsPos = float3(AreaLightsMatrix[Num][0][3], AreaLightsMatrix[Num][1][3],AreaLightsMatrix[Num][2][3]);
    float3 VoxelLS =  mul( float4(VoxelWS.xyz,1)-lsPos, AreaLightsMatrix[Num]);
    float4 areaLightAccumulation = float4(0,0,0,0);
    if (VoxelLS.z <= 0) return areaLightAccumulation; //Early out
    uint3 id =  DispatchRaysIndex().xyz; //redundent, oh well

  for (int j = 0; j < AreaLightSamples; j++) 
  {
    //int loop64 = fmod(j + AreaLightSamples + id.x+id.y+id.z,64);
    float3 LocalPos = mul(AreaLightsWS[Num].xyz -lsPos , AreaLightsMatrix[Num]).xyz ;
    float3 LightPosSample = LocalPos + float3( (rand(id.xyz + j)-0.5) *  AreaLightsSize[Num].x , (rand(id.xyz+j+20)-0.5) * AreaLightsSize[Num].y,0);
    //float3 LightPosSample = LocalPos + float3( BlueNoiseInDisk[loop64].x *  AreaLightsSize[Num].x * 0.5  , BlueNoiseInDisk[loop64].y * AreaLightsSize[Num].y *0.5, 0   );

    float LightRadius = distance(VoxelLS, LightPosSample ); 

	float3 rayDirection = -normalize(VoxelLS - LightPosSample);

	float attenuation = saturate(dot(float3(0,0,1), -rayDirection));

    RayDesc ray;
    ray.Origin    = VoxelWS;
    ray.Direction = mul(rayDirection, AreaLightsMatrixInv[Num]);
    ray.TMin      = 0.0f;
    ray.TMax      = LightRadius;

    RayPayload payload;
    payload.color = float4(0, 0, 0, 0);

    uint missShaderIndex = 0;
    TraceRay(g_SceneAccelStruct, 0, 0xFF, 0, 1, missShaderIndex, ray, payload); //Add an anyhit shader to support transparencies 

    areaLightAccumulation += saturate(InverseSquare(LightRadius) * payload.color * AreaLightsColor[Num] * attenuation) / AreaLightSamples;
   }
	return  areaLightAccumulation;
}

//
//Disk light
//

float4 DiscLightCast(float3 VoxelWS, uint Num){
  //  
    float3 lsPos = float3(AreaLightsMatrix[Num][0][3], AreaLightsMatrix[Num][1][3],AreaLightsMatrix[Num][2][3]);
    float3 VoxelLS =  mul( float4(VoxelWS.xyz,1)-lsPos, AreaLightsMatrix[Num]);
    float3 IntialDirection =  -normalize(VoxelWS - AreaLightsWS[Num])  ;
    uint3 id =  DispatchRaysIndex().xyz;
    float4 areaLightAccumulation = float4(0,0,0,0);
    if (VoxelLS.z <= 0) return areaLightAccumulation;

  for (int j = 0; j < AreaLightSamples; j++) 
  {
    float3 LocalPos = mul(AreaLightsWS[Num].xyz -lsPos , AreaLightsMatrix[Num]).xyz ;
    //https://stackoverflow.com/questions/5837572/generate-a-random-point-within-a-circle-uniformly
    float t = 2 * M_PI * rand(id.xyz + j + 30);
    float u = rand(id.xyz + j) + rand(id.xyz + j + 20);
    float r;
    if (u > 1) r = (2 - u);
    else  r = u;
    //	[r * cos(t), r * sin(t)]

    float3 LightPosSample = LocalPos +  
        float3( ( r * cos(t)) * AreaLightsSize[Num].x,
                ( r * sin(t)) * AreaLightsSize[Num].x,
                0);


    float LightRadius = distance(VoxelLS, LightPosSample ); 

	float3 rayDirection = -normalize(VoxelLS - LightPosSample);

	float attenuation = saturate(dot(float3(0,0,1), -rayDirection));

    RayDesc ray;
    ray.Origin    = VoxelWS;
    ray.Direction = mul(rayDirection, AreaLightsMatrixInv[Num]);
    ray.TMin      = 0.0f;
    ray.TMax      = LightRadius;

    RayPayload payload;
    payload.color = float4(0, 0, 0, 0);

    uint missShaderIndex = 0;
    TraceRay(g_SceneAccelStruct, 0, 0xFF, 0, 1, missShaderIndex, ray, payload); //Add an anyhit shader to support transparencies 

    areaLightAccumulation += saturate(InverseSquare(LightRadius) * payload.color * AreaLightsColor[Num] * attenuation) / AreaLightSamples;
   }
	return  areaLightAccumulation;
}

//
// Main shader
//

[shader("raygeneration")]
void MainRayGenShader()
{
    float3 launchIndex = DispatchRaysIndex().xyz; //id
    float3 launchDim = DispatchRaysDimensions().xyz; //whd
    float3 VoxelWorldPosition = WPosition + ( ( launchIndex/launchDim ) / Size );

	float4 LightAccumulation = float4(0,0,0,0);

	for (int i=0; i< PointLightCount; i++)  LightAccumulation += PointLightCast(VoxelWorldPosition, i) ; 
	for (int i=0; i< ConeLightCount; i++)	LightAccumulation += ConeLightCast(VoxelWorldPosition, i) ; 
	for (int i=0; i< DirLightCount; i++)	LightAccumulation += DirLightCast(VoxelWorldPosition, i) ; 
	for (int i=0; i< AreaLightCount; i++){	
      if (AreaLightsSize[i].z == 0)  LightAccumulation += AreaLightCast(VoxelWorldPosition, i) ; 
      else  LightAccumulation += DiscLightCast(VoxelWorldPosition, i) ;
    }


    g_Output[launchIndex] = LightAccumulation; // += for light multipass
}
///////////////////////////////////////

//
//[numthreads(4, 4, 4)]
//void RectangleLight(uint3 id : SV_DispatchThreadID) {

//	float3 whd;
//	AccumulatedLights.GetDimensions(whd.x, whd.y, whd.z);
//	float3 VoxelWorldPosition = Position + ((id + 0.5) / (whd / Size));

//	float4 MonteCarlointegration = float4(0, 0, 0, 0);

//	for (int i = 0; i < AreaLightSamples; i++) {

//		float4 ShadowColor = float4(1, 1, 1, 1);

//		float3 VoxelDirectionToLight = -normalize(VoxelWorldPosition - LightPosition);

//		float Facing = saturate(dot(LightDirection, -VoxelDirectionToLight)); //Intal direction check

//		//Only cast rays from one side of the light
//		if (Facing > 0){

//			float3 LightPosSample = LightPosition + mul(AreaMatrix, float3( (rand(id.xyz)-0.5) * AreaSize.x , (rand(id.xyz) - 0.5) * AreaSize.y, 0) );

//			VoxelDirectionToLight = -normalize(VoxelWorldPosition - LightPosSample);

//			float LightRadius = (distance(VoxelWorldPosition, LightPosSample)); //Distance from center of voxel

//			float attenuation = saturate(dot(LightDirection, -VoxelDirectionToLight));

//			Ray PointShadowRay = CreateRay(VoxelWorldPosition, -normalize(VoxelWorldPosition - LightPosSample) );

//			RayHit PointShadowHit = Trace(PointShadowRay);

//			if (PointShadowHit.distance < LightRadius)
//			{
//				//todo: Account for tinted materials to make colored shadows
//				ShadowColor *= 0;
//			}
//			//TODO: figure out what's unity's area lighting model is and match it 
//			float4 inverseSquareColor = (LightColor ) / (4 * M_PI * LightRadius * LightRadius);

//			MonteCarlointegration += (inverseSquareColor * ShadowColor * attenuation) / AreaLightSamples;

//		}
//		//Currently just doing the inverse square law for falloff. Figure out physical scattering and absorption 
//	}

////	AccumulatedLights[id] += MonteCarlointegration;
//	SaveLightTexture(id, MonteCarlointegration);
//}